(()=>{var __webpack_modules__={46:()=>{eval("// @ts-nocheck\r\n(function (window){\r\n    'use strict';\r\n    console.log('Started to run DOM handler');\r\n    /**\r\n     * Provides some kind of Singleton pattern functionality for DOM handler\r\n     */\r\n    window['domhandlerisrunning'] = window['domhandlerisrunning'] || false;\r\n\r\n    if(window['domhandlerisrunning']){\r\n        return;\r\n    } \r\n    window['domhandlerisrunning'] = true;\r\n\r\n    const ELEMENT_NODE = 1;\r\n    const ATTRIBUTE_NODE = 2;\r\n\r\n    let elementLookup = new Array();\r\n    let eventsLookup = new Array();\r\n    let originals = {};\r\n    let blockedEventTypes = new Array();\r\n\r\n    /**\r\n     * Stores prototypes of EventTarget and HTMLElement\r\n     */\r\n    let prototypes = {\r\n        element: window.HTMLElement.prototype,\r\n        eventTarget: EventTarget.prototype\r\n    };\r\n    /**\r\n     * This callback function used by MutationObserver\r\n     * to detect if there is any of newly created eleemnts\r\n     * has inline events and if there are - registers then on\r\n     * DOM handler's registry.\r\n     * \r\n     * @param {Array<MutationRecord>} mutationsList \r\n     * @param {MutationObserver} observer \r\n     */\r\n    let mutationObserverCallback = function (mutationsList, observer){\r\n        mutationsList.forEach(function(mutation){\r\n            switch(mutation.type){\r\n                 case 'attributes':\r\n                   if(\r\n                        mutation.attributeName.toLowerCase().indexOf('on') === 0 && \r\n                        typeof(mutation.target.getAttribute(mutation.attributeName)) == 'string'\r\n                    ){\r\n                        \r\n                        _registerEventListener(\r\n                            mutation.target, \r\n                            _normilizeEventType(mutation.attributeName.toLowerCase()),\r\n                            mutation.target.getAttribute(mutation.attributeName),\r\n                            true,\r\n                            true\r\n                        );\r\n                    }\r\n                    break;\r\n                case 'childList':\r\n                    //added nodes\r\n                    for(let index = 0, maxIndex = mutation.addedNodes.length; index < maxIndex; index += 1){\r\n                        let node = mutation.addedNodes[index];\r\n\r\n                        if(node.nodeType != ELEMENT_NODE){\r\n                            continue;\r\n                        }\r\n\r\n                        for(let attributesIndex = 0, maxAttributesIndex = node.attributes.length; attributesIndex < maxAttributesIndex; attributesIndex += 1){\r\n                            let attribute = node.attributes[attributesIndex];\r\n                            \r\n                            if(attribute.nodeType != ATTRIBUTE_NODE || attribute.name.toLowerCase() == 'style'){\r\n                                continue;\r\n                            }\r\n\r\n                            if(attribute.name.toLowerCase().indexOf('on') === 0){\r\n                                _registerEventListener(\r\n                                    node, \r\n                                    _normilizeEventType(attribute.name.toLowerCase()),\r\n                                    node.getAttribute(attribute.name),\r\n                                    true,\r\n                                    true\r\n                                );\r\n                            }\r\n                        }\r\n                    }\r\n                    //removed nodes\r\n                    for (let index = 0, maxIndex = mutation.removedNodes.length; index < maxIndex; index += 1) {\r\n                        const element = mutation.removedNodes[index];\r\n                        if (element.id && elementLookup[element.id] && elementLookup[element.id].events) {\r\n                            const allEvenet = Object.keys(elementLookup[element.id].events);\r\n                            delete elementLookup[element.id];\r\n                            allEvenet.forEach(_event => {\r\n                                const event = \"_\" + _event;\r\n                                eventsLookup[event].Elements = eventsLookup[event].Elements.filter(el => el != element);\r\n                            });\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    };\r\n   \r\n    /**\r\n     * Whenever whole DOM is ready, start listening for DOM changes by\r\n     * MutationObserver.\r\n     */\r\n    window.document.addEventListener('DOMContentLoaded', function(){\r\n        let mutationObserver = new MutationObserver(mutationObserverCallback);\r\n\r\n        mutationObserver.observe(\r\n            window.document.body,\r\n            {\r\n                attributes: true, \r\n                childList: true, \r\n                subtree: true,\r\n                characterData: false \r\n            }\r\n        );\r\n\r\n        let allElementsWithInlineEvents = _findElementsWithArributePrefix('*', 'on');\r\n\r\n        for(let index = 0, maxIndex = allElementsWithInlineEvents.length; index < maxIndex; index += 1){\r\n            let element = allElementsWithInlineEvents[index];\r\n\r\n            for(let attributesIndex = 0, maxAttributesIndex = element.attributes.length; attributesIndex < maxAttributesIndex; attributesIndex += 1){\r\n                let attribute = element.attributes[attributesIndex];\r\n\r\n                if(attribute.name.startsWith('on')){\r\n                    _registerEventListener(\r\n                        element, \r\n                        _normilizeEventType(attribute.name.toLowerCase()),\r\n                        element.getAttribute(attribute.name),\r\n                        true,\r\n                        true\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Serches for DOM elements compliant with givent CSS selector\r\n     * and has attribute which name starts with given prefix.\r\n     * \r\n     * @param {string} selector \r\n     * @param {string} prefix \r\n     */\r\n    function _findElementsWithArributePrefix(selector, prefix)\r\n    {\r\n        return [].slice.call(document.querySelectorAll(selector)).filter(function (e)\r\n        {\r\n            return [].slice.call(e.attributes).filter(\r\n                function (attr)\r\n                {\r\n                    return attr.name.startsWith(prefix);\r\n                }\r\n            ).length;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generates RFC-4122 compliant\r\n     * v4 unique identifier \r\n     */\r\n    function _uuidv4() {\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n            let r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n\r\n            return v.toString(16);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * This delegate function used by Element.addEventListener wrapper \r\n     * instead of original native delegate.\r\n     * \r\n     * @param {string} type \r\n     * @param {function} listener \r\n     * @param {boolean} useCapture \r\n     */\r\n    function _wrappedAddEventListenerElementDelegate(type, listener, useCapture) {\r\n        let eventType = _normilizeEventType(type);\r\n        let targetElement = this;\r\n\r\n        if(blockedEventTypes.includes(eventType)){\r\n            return;\r\n        }\r\n\r\n        try {\r\n            _registerEventListener(targetElement, eventType, listener, useCapture);\r\n        } catch (error) {\r\n            console.log(error);\r\n         } finally {\r\n            originals['element'].addEventListener.call(this, type, listener, useCapture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This delegate function used by EventTarget.addEventListener wrapper \r\n     * instead of original native delegate.\r\n     * \r\n     * @param {string} type \r\n     * @param {function} listener \r\n     * @param {boolean} useCapture \r\n     */\r\n    function _wrappedAddEventListenerEventTargetDelegate(type, listener, useCapture) {\r\n        let eventType = _normilizeEventType(type);\r\n        let targetElement = this;\r\n\r\n        if(blockedEventTypes.includes(eventType)){\r\n            return;\r\n        }\r\n\r\n        try {\r\n            _registerEventListener(targetElement, eventType, listener, useCapture);\r\n        } catch (error) { \r\n            console.log(error);\r\n        } finally {\r\n            originals['eventTarget'].addEventListener.call(this, type, listener, useCapture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns unified event name\r\n     * \r\n     * @param {string} type \r\n     */\r\n    function _normilizeEventType(type) {\r\n        type = type.toLowerCase();\r\n\r\n        if (type.indexOf(\"on\") === 0)\r\n        {\r\n            type = type.substring(2, type.length);\r\n        }\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Serches given element in\r\n     * DOM handler's registry\r\n     * \r\n     * @param {HTMLElement} element \r\n     */\r\n    function _getElementFormLookup(element){\r\n        \r\n        if(typeof(element.id) === 'undefined' || element.id == null || element.id === ''){\r\n            element.id = 'uTester-' + _uuidv4();\r\n        }\r\n        if (!document.body.contains(element)) return { element: element, events: {} };\r\n        elementLookup[element.id] = elementLookup[element.id] || {\r\n            element: element,\r\n            events: {}\r\n        };\r\n\r\n        return elementLookup[element.id];\r\n    }\r\n\r\n    /**\r\n     * Serches enrty of given type in\r\n     * DOM handler's registry\r\n     * \r\n     * @param {string} type \r\n     */\r\n    function _getEventFromLookup(type) {\r\n        const _type = \"_\" + type;\r\n        eventsLookup[_type] = eventsLookup[_type] || {\r\n            Elements: new Array()\r\n        };\r\n\r\n        return eventsLookup[_type];\r\n    }\r\n\r\n    /**\r\n     * Register element that have event listener of assigned type into \r\n     * DOM handler's registtry\r\n     * \r\n     * @param {HTMLElement} element \r\n     * @param {string} type \r\n     * @param {Function} listener \r\n     * @param {boolean} useCapture \r\n     * @param {boolean} isInline \r\n     */\r\n    function _registerEventListener(element, type, listener, useCapture, isInline){\r\n        if(!element || element.nodeType != ELEMENT_NODE || !document.body || !document.body.contains(element) || (typeof listener === \"string\" && listener.length === 0)){\r\n            return;\r\n        }\r\n\r\n        let lookupItem = _getElementFormLookup(element);\r\n\r\n        lookupItem.events[type] = lookupItem.events[type] || {\r\n            listeners: []\r\n        };\r\n\r\n        lookupItem.events[type].listeners.push({\r\n            listener: listener,\r\n            useCapture: (useCapture === true),\r\n            isInline: (isInline === true)\r\n        });\r\n\r\n        let eventLookupItem = _getEventFromLookup(type);\r\n        \r\n        if(eventLookupItem.Elements.indexOf(element) === -1){\r\n            eventLookupItem.Elements.push(element);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wraps Element.addEventListener method\r\n     */\r\n    function _wrapElementAddEventListener() {\r\n        originals['element'] = {\r\n            addEventListener: prototypes.element.addEventListener\r\n        };\r\n        \r\n        prototypes.element.addEventListener = _wrappedAddEventListenerElementDelegate;\r\n    }\r\n\r\n    /**\r\n     * Wraps targetEvent.addEventListener method\r\n     */\r\n    function _wrapEventTargetAddEventListener(){\r\n        originals['eventTarget'] = {\r\n            addEventListener: prototypes.eventTarget.addEventListener\r\n        };\r\n        \r\n        prototypes.eventTarget.addEventListener = _wrappedAddEventListenerEventTargetDelegate;\r\n    }\r\n\r\n    _wrapElementAddEventListener();\r\n    _wrapEventTargetAddEventListener();\r\n\r\n    /**\r\n     * Propogate DOM handler to window \r\n     * so everyone who need it can call it.\r\n     */\r\n    window.u1st_domHandler = {\r\n        /**\r\n         * Returns all elements that has event listeners resistered by DOM handler.\r\n         */\r\n        getAllElementsWithEvents: function () {\r\n            elementLookup.forEach((event) => {\r\n                elementLookup[event].Elements = elementLookup[event].Elements ? eventsLookup[event].Elements.filter(el => el.parentElement) : [];\r\n            })\r\n            return elementLookup;\r\n        },\r\n        /**\r\n         * Returns all elements taht has event listeners\r\n         * of given types.\r\n         * \r\n         * @param {Array<string>} types \r\n         * @param {boolean} includeOnlyBodyElements \r\n         */\r\n        getAllElementsWithSpecificEvents: function(types, includeOnlyBodyElements = false) {\r\n            let events = new Array();\r\n            const eventsMap = Object.keys(eventsLookup);\r\n            const _types = types.map(v => \"_\" + v);\r\n            for(let index = 0, maxIndex = _types.length; index < maxIndex; index += 1){\r\n                if (eventsMap.indexOf(_types[index]) > -1 && eventsLookup[_types[index]].Elements) {\r\n                    eventsLookup[_types[index]].Elements = eventsLookup[_types[index]].Elements.filter(el => el.parentElement);\r\n                    events[(_types[index]).substring(1)] = eventsLookup[_types[index]];\r\n                }\r\n            }\r\n\r\n            return events;\r\n        },\r\n        getElementEvents: function(element){\r\n            return _getElementFormLookup(element);\r\n        },\r\n        elementLookup,\r\n        eventsLookup\r\n    };\r\n\r\n    console.log('Done runing DOM handler.');\r\n})(window);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oYWNrYXRob24vLi9kb21oYW5kbGVyLmpzP2E3NTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcclxuKGZ1bmN0aW9uICh3aW5kb3cpe1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgY29uc29sZS5sb2coJ1N0YXJ0ZWQgdG8gcnVuIERPTSBoYW5kbGVyJyk7XHJcbiAgICAvKipcclxuICAgICAqIFByb3ZpZGVzIHNvbWUga2luZCBvZiBTaW5nbGV0b24gcGF0dGVybiBmdW5jdGlvbmFsaXR5IGZvciBET00gaGFuZGxlclxyXG4gICAgICovXHJcbiAgICB3aW5kb3dbJ2RvbWhhbmRsZXJpc3J1bm5pbmcnXSA9IHdpbmRvd1snZG9taGFuZGxlcmlzcnVubmluZyddIHx8IGZhbHNlO1xyXG5cclxuICAgIGlmKHdpbmRvd1snZG9taGFuZGxlcmlzcnVubmluZyddKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9IFxyXG4gICAgd2luZG93Wydkb21oYW5kbGVyaXNydW5uaW5nJ10gPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IEVMRU1FTlRfTk9ERSA9IDE7XHJcbiAgICBjb25zdCBBVFRSSUJVVEVfTk9ERSA9IDI7XHJcblxyXG4gICAgbGV0IGVsZW1lbnRMb29rdXAgPSBuZXcgQXJyYXkoKTtcclxuICAgIGxldCBldmVudHNMb29rdXAgPSBuZXcgQXJyYXkoKTtcclxuICAgIGxldCBvcmlnaW5hbHMgPSB7fTtcclxuICAgIGxldCBibG9ja2VkRXZlbnRUeXBlcyA9IG5ldyBBcnJheSgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RvcmVzIHByb3RvdHlwZXMgb2YgRXZlbnRUYXJnZXQgYW5kIEhUTUxFbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGxldCBwcm90b3R5cGVzID0ge1xyXG4gICAgICAgIGVsZW1lbnQ6IHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUsXHJcbiAgICAgICAgZXZlbnRUYXJnZXQ6IEV2ZW50VGFyZ2V0LnByb3RvdHlwZVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBjYWxsYmFjayBmdW5jdGlvbiB1c2VkIGJ5IE11dGF0aW9uT2JzZXJ2ZXJcclxuICAgICAqIHRvIGRldGVjdCBpZiB0aGVyZSBpcyBhbnkgb2YgbmV3bHkgY3JlYXRlZCBlbGVlbW50c1xyXG4gICAgICogaGFzIGlubGluZSBldmVudHMgYW5kIGlmIHRoZXJlIGFyZSAtIHJlZ2lzdGVycyB0aGVuIG9uXHJcbiAgICAgKiBET00gaGFuZGxlcidzIHJlZ2lzdHJ5LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PE11dGF0aW9uUmVjb3JkPn0gbXV0YXRpb25zTGlzdCBcclxuICAgICAqIEBwYXJhbSB7TXV0YXRpb25PYnNlcnZlcn0gb2JzZXJ2ZXIgXHJcbiAgICAgKi9cclxuICAgIGxldCBtdXRhdGlvbk9ic2VydmVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAobXV0YXRpb25zTGlzdCwgb2JzZXJ2ZXIpe1xyXG4gICAgICAgIG11dGF0aW9uc0xpc3QuZm9yRWFjaChmdW5jdGlvbihtdXRhdGlvbil7XHJcbiAgICAgICAgICAgIHN3aXRjaChtdXRhdGlvbi50eXBlKXtcclxuICAgICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcclxuICAgICAgICAgICAgICAgICAgIGlmKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignb24nKSA9PT0gMCAmJiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mKG11dGF0aW9uLnRhcmdldC5nZXRBdHRyaWJ1dGUobXV0YXRpb24uYXR0cmlidXRlTmFtZSkpID09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgICAgICAgICAgKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWdpc3RlckV2ZW50TGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbi50YXJnZXQsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX25vcm1pbGl6ZUV2ZW50VHlwZShtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24udGFyZ2V0LmdldEF0dHJpYnV0ZShtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcclxuICAgICAgICAgICAgICAgICAgICAvL2FkZGVkIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpbmRleCA9IDAsIG1heEluZGV4ID0gbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGluZGV4IDwgbWF4SW5kZXg7IGluZGV4ICs9IDEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZS5ub2RlVHlwZSAhPSBFTEVNRU5UX05PREUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgYXR0cmlidXRlc0luZGV4ID0gMCwgbWF4QXR0cmlidXRlc0luZGV4ID0gbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cmlidXRlc0luZGV4IDwgbWF4QXR0cmlidXRlc0luZGV4OyBhdHRyaWJ1dGVzSW5kZXggKz0gMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzW2F0dHJpYnV0ZXNJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJpYnV0ZS5ub2RlVHlwZSAhPSBBVFRSSUJVVEVfTk9ERSB8fCBhdHRyaWJ1dGUubmFtZS50b0xvd2VyQ2FzZSgpID09ICdzdHlsZScpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJpYnV0ZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignb24nKSA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlZ2lzdGVyRXZlbnRMaXN0ZW5lcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ub3JtaWxpemVFdmVudFR5cGUoYXR0cmlidXRlLm5hbWUudG9Mb3dlckNhc2UoKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmVkIG5vZGVzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBtYXhJbmRleCA9IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGluZGV4IDwgbWF4SW5kZXg7IGluZGV4ICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmlkICYmIGVsZW1lbnRMb29rdXBbZWxlbWVudC5pZF0gJiYgZWxlbWVudExvb2t1cFtlbGVtZW50LmlkXS5ldmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbEV2ZW5ldCA9IE9iamVjdC5rZXlzKGVsZW1lbnRMb29rdXBbZWxlbWVudC5pZF0uZXZlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50TG9va3VwW2VsZW1lbnQuaWRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRXZlbmV0LmZvckVhY2goX2V2ZW50ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudCA9IFwiX1wiICsgX2V2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50c0xvb2t1cFtldmVudF0uRWxlbWVudHMgPSBldmVudHNMb29rdXBbZXZlbnRdLkVsZW1lbnRzLmZpbHRlcihlbCA9PiBlbCAhPSBlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICBcclxuICAgIC8qKlxyXG4gICAgICogV2hlbmV2ZXIgd2hvbGUgRE9NIGlzIHJlYWR5LCBzdGFydCBsaXN0ZW5pbmcgZm9yIERPTSBjaGFuZ2VzIGJ5XHJcbiAgICAgKiBNdXRhdGlvbk9ic2VydmVyLlxyXG4gICAgICovXHJcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgbGV0IG11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbk9ic2VydmVyQ2FsbGJhY2spO1xyXG5cclxuICAgICAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoXHJcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLCBcclxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSwgXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyRGF0YTogZmFsc2UgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBsZXQgYWxsRWxlbWVudHNXaXRoSW5saW5lRXZlbnRzID0gX2ZpbmRFbGVtZW50c1dpdGhBcnJpYnV0ZVByZWZpeCgnKicsICdvbicpO1xyXG5cclxuICAgICAgICBmb3IobGV0IGluZGV4ID0gMCwgbWF4SW5kZXggPSBhbGxFbGVtZW50c1dpdGhJbmxpbmVFdmVudHMubGVuZ3RoOyBpbmRleCA8IG1heEluZGV4OyBpbmRleCArPSAxKXtcclxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBhbGxFbGVtZW50c1dpdGhJbmxpbmVFdmVudHNbaW5kZXhdO1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCBhdHRyaWJ1dGVzSW5kZXggPSAwLCBtYXhBdHRyaWJ1dGVzSW5kZXggPSBlbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyaWJ1dGVzSW5kZXggPCBtYXhBdHRyaWJ1dGVzSW5kZXg7IGF0dHJpYnV0ZXNJbmRleCArPSAxKXtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZXNbYXR0cmlidXRlc0luZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihhdHRyaWJ1dGUubmFtZS5zdGFydHNXaXRoKCdvbicpKXtcclxuICAgICAgICAgICAgICAgICAgICBfcmVnaXN0ZXJFdmVudExpc3RlbmVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgX25vcm1pbGl6ZUV2ZW50VHlwZShhdHRyaWJ1dGUubmFtZS50b0xvd2VyQ2FzZSgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VyY2hlcyBmb3IgRE9NIGVsZW1lbnRzIGNvbXBsaWFudCB3aXRoIGdpdmVudCBDU1Mgc2VsZWN0b3JcclxuICAgICAqIGFuZCBoYXMgYXR0cmlidXRlIHdoaWNoIG5hbWUgc3RhcnRzIHdpdGggZ2l2ZW4gcHJlZml4LlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZmluZEVsZW1lbnRzV2l0aEFycmlidXRlUHJlZml4KHNlbGVjdG9yLCBwcmVmaXgpXHJcbiAgICB7XHJcbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpLmZpbHRlcihmdW5jdGlvbiAoZSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGUuYXR0cmlidXRlcykuZmlsdGVyKFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGF0dHIpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHIubmFtZS5zdGFydHNXaXRoKHByZWZpeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICkubGVuZ3RoO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIFJGQy00MTIyIGNvbXBsaWFudFxyXG4gICAgICogdjQgdW5pcXVlIGlkZW50aWZpZXIgXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF91dWlkdjQoKSB7XHJcbiAgICAgICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xyXG4gICAgICAgICAgICBsZXQgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDAsIHYgPSBjID09ICd4JyA/IHIgOiAociAmIDB4MyB8IDB4OCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGRlbGVnYXRlIGZ1bmN0aW9uIHVzZWQgYnkgRWxlbWVudC5hZGRFdmVudExpc3RlbmVyIHdyYXBwZXIgXHJcbiAgICAgKiBpbnN0ZWFkIG9mIG9yaWdpbmFsIG5hdGl2ZSBkZWxlZ2F0ZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZSBcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX3dyYXBwZWRBZGRFdmVudExpc3RlbmVyRWxlbWVudERlbGVnYXRlKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VHlwZSA9IF9ub3JtaWxpemVFdmVudFR5cGUodHlwZSk7XHJcbiAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZihibG9ja2VkRXZlbnRUeXBlcy5pbmNsdWRlcyhldmVudFR5cGUpKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgX3JlZ2lzdGVyRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsc1snZWxlbWVudCddLmFkZEV2ZW50TGlzdGVuZXIuY2FsbCh0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBkZWxlZ2F0ZSBmdW5jdGlvbiB1c2VkIGJ5IEV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIgd3JhcHBlciBcclxuICAgICAqIGluc3RlYWQgb2Ygb3JpZ2luYWwgbmF0aXZlIGRlbGVnYXRlLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1c2VDYXB0dXJlIFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfd3JhcHBlZEFkZEV2ZW50TGlzdGVuZXJFdmVudFRhcmdldERlbGVnYXRlKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50VHlwZSA9IF9ub3JtaWxpemVFdmVudFR5cGUodHlwZSk7XHJcbiAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZihibG9ja2VkRXZlbnRUeXBlcy5pbmNsdWRlcyhldmVudFR5cGUpKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgX3JlZ2lzdGVyRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikgeyBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgIG9yaWdpbmFsc1snZXZlbnRUYXJnZXQnXS5hZGRFdmVudExpc3RlbmVyLmNhbGwodGhpcywgdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdW5pZmllZCBldmVudCBuYW1lXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfbm9ybWlsaXplRXZlbnRUeXBlKHR5cGUpIHtcclxuICAgICAgICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICBpZiAodHlwZS5pbmRleE9mKFwib25cIikgPT09IDApXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0eXBlID0gdHlwZS5zdWJzdHJpbmcoMiwgdHlwZS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlcmNoZXMgZ2l2ZW4gZWxlbWVudCBpblxyXG4gICAgICogRE9NIGhhbmRsZXIncyByZWdpc3RyeVxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0RWxlbWVudEZvcm1Mb29rdXAoZWxlbWVudCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodHlwZW9mKGVsZW1lbnQuaWQpID09PSAndW5kZWZpbmVkJyB8fCBlbGVtZW50LmlkID09IG51bGwgfHwgZWxlbWVudC5pZCA9PT0gJycpe1xyXG4gICAgICAgICAgICBlbGVtZW50LmlkID0gJ3VUZXN0ZXItJyArIF91dWlkdjQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsZW1lbnQpKSByZXR1cm4geyBlbGVtZW50OiBlbGVtZW50LCBldmVudHM6IHt9IH07XHJcbiAgICAgICAgZWxlbWVudExvb2t1cFtlbGVtZW50LmlkXSA9IGVsZW1lbnRMb29rdXBbZWxlbWVudC5pZF0gfHwge1xyXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICAgICAgICBldmVudHM6IHt9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRMb29rdXBbZWxlbWVudC5pZF07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXJjaGVzIGVucnR5IG9mIGdpdmVuIHR5cGUgaW5cclxuICAgICAqIERPTSBoYW5kbGVyJ3MgcmVnaXN0cnlcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRFdmVudEZyb21Mb29rdXAodHlwZSkge1xyXG4gICAgICAgIGNvbnN0IF90eXBlID0gXCJfXCIgKyB0eXBlO1xyXG4gICAgICAgIGV2ZW50c0xvb2t1cFtfdHlwZV0gPSBldmVudHNMb29rdXBbX3R5cGVdIHx8IHtcclxuICAgICAgICAgICAgRWxlbWVudHM6IG5ldyBBcnJheSgpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGV2ZW50c0xvb2t1cFtfdHlwZV07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBlbGVtZW50IHRoYXQgaGF2ZSBldmVudCBsaXN0ZW5lciBvZiBhc3NpZ25lZCB0eXBlIGludG8gXHJcbiAgICAgKiBET00gaGFuZGxlcidzIHJlZ2lzdHRyeVxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQ2FwdHVyZSBcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNJbmxpbmUgXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9yZWdpc3RlckV2ZW50TGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUsIGlzSW5saW5lKXtcclxuICAgICAgICBpZighZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9IEVMRU1FTlRfTk9ERSB8fCAhZG9jdW1lbnQuYm9keSB8fCAhZG9jdW1lbnQuYm9keS5jb250YWlucyhlbGVtZW50KSB8fCAodHlwZW9mIGxpc3RlbmVyID09PSBcInN0cmluZ1wiICYmIGxpc3RlbmVyLmxlbmd0aCA9PT0gMCkpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbG9va3VwSXRlbSA9IF9nZXRFbGVtZW50Rm9ybUxvb2t1cChlbGVtZW50KTtcclxuXHJcbiAgICAgICAgbG9va3VwSXRlbS5ldmVudHNbdHlwZV0gPSBsb29rdXBJdGVtLmV2ZW50c1t0eXBlXSB8fCB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyczogW11cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsb29rdXBJdGVtLmV2ZW50c1t0eXBlXS5saXN0ZW5lcnMucHVzaCh7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcclxuICAgICAgICAgICAgdXNlQ2FwdHVyZTogKHVzZUNhcHR1cmUgPT09IHRydWUpLFxyXG4gICAgICAgICAgICBpc0lubGluZTogKGlzSW5saW5lID09PSB0cnVlKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgZXZlbnRMb29rdXBJdGVtID0gX2dldEV2ZW50RnJvbUxvb2t1cCh0eXBlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZihldmVudExvb2t1cEl0ZW0uRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KSA9PT0gLTEpe1xyXG4gICAgICAgICAgICBldmVudExvb2t1cEl0ZW0uRWxlbWVudHMucHVzaChlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcyBFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF93cmFwRWxlbWVudEFkZEV2ZW50TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgb3JpZ2luYWxzWydlbGVtZW50J10gPSB7XHJcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IHByb3RvdHlwZXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyXHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICBwcm90b3R5cGVzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9IF93cmFwcGVkQWRkRXZlbnRMaXN0ZW5lckVsZW1lbnREZWxlZ2F0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdyYXBzIHRhcmdldEV2ZW50LmFkZEV2ZW50TGlzdGVuZXIgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF93cmFwRXZlbnRUYXJnZXRBZGRFdmVudExpc3RlbmVyKCl7XHJcbiAgICAgICAgb3JpZ2luYWxzWydldmVudFRhcmdldCddID0ge1xyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBwcm90b3R5cGVzLmV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXJcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHByb3RvdHlwZXMuZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciA9IF93cmFwcGVkQWRkRXZlbnRMaXN0ZW5lckV2ZW50VGFyZ2V0RGVsZWdhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgX3dyYXBFbGVtZW50QWRkRXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgX3dyYXBFdmVudFRhcmdldEFkZEV2ZW50TGlzdGVuZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFByb3BvZ2F0ZSBET00gaGFuZGxlciB0byB3aW5kb3cgXHJcbiAgICAgKiBzbyBldmVyeW9uZSB3aG8gbmVlZCBpdCBjYW4gY2FsbCBpdC5cclxuICAgICAqL1xyXG4gICAgd2luZG93LnUxc3RfZG9tSGFuZGxlciA9IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhhcyBldmVudCBsaXN0ZW5lcnMgcmVzaXN0ZXJlZCBieSBET00gaGFuZGxlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRBbGxFbGVtZW50c1dpdGhFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZWxlbWVudExvb2t1cC5mb3JFYWNoKChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudExvb2t1cFtldmVudF0uRWxlbWVudHMgPSBlbGVtZW50TG9va3VwW2V2ZW50XS5FbGVtZW50cyA/IGV2ZW50c0xvb2t1cFtldmVudF0uRWxlbWVudHMuZmlsdGVyKGVsID0+IGVsLnBhcmVudEVsZW1lbnQpIDogW107XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50TG9va3VwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhbGwgZWxlbWVudHMgdGFodCBoYXMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgICAgICogb2YgZ2l2ZW4gdHlwZXMuXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB0eXBlcyBcclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVPbmx5Qm9keUVsZW1lbnRzIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldEFsbEVsZW1lbnRzV2l0aFNwZWNpZmljRXZlbnRzOiBmdW5jdGlvbih0eXBlcywgaW5jbHVkZU9ubHlCb2R5RWxlbWVudHMgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50c01hcCA9IE9iamVjdC5rZXlzKGV2ZW50c0xvb2t1cCk7XHJcbiAgICAgICAgICAgIGNvbnN0IF90eXBlcyA9IHR5cGVzLm1hcCh2ID0+IFwiX1wiICsgdik7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaW5kZXggPSAwLCBtYXhJbmRleCA9IF90eXBlcy5sZW5ndGg7IGluZGV4IDwgbWF4SW5kZXg7IGluZGV4ICs9IDEpe1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50c01hcC5pbmRleE9mKF90eXBlc1tpbmRleF0pID4gLTEgJiYgZXZlbnRzTG9va3VwW190eXBlc1tpbmRleF1dLkVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzTG9va3VwW190eXBlc1tpbmRleF1dLkVsZW1lbnRzID0gZXZlbnRzTG9va3VwW190eXBlc1tpbmRleF1dLkVsZW1lbnRzLmZpbHRlcihlbCA9PiBlbC5wYXJlbnRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHNbKF90eXBlc1tpbmRleF0pLnN1YnN0cmluZygxKV0gPSBldmVudHNMb29rdXBbX3R5cGVzW2luZGV4XV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXRFbGVtZW50RXZlbnRzOiBmdW5jdGlvbihlbGVtZW50KXtcclxuICAgICAgICAgICAgcmV0dXJuIF9nZXRFbGVtZW50Rm9ybUxvb2t1cChlbGVtZW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVsZW1lbnRMb29rdXAsXHJcbiAgICAgICAgZXZlbnRzTG9va3VwXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdEb25lIHJ1bmluZyBET00gaGFuZGxlci4nKTtcclxufSkod2luZG93KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///46\n")}},__webpack_exports__={};__webpack_modules__[46]()})();